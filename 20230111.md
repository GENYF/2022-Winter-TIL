# 2023.01.10

## 클린코드 스터디

### 1장 **깨끗한 코드**

강동우

- 새 코드를 짜면서 우리는 기존 코드를 읽는다.
    - 과제나 공부를 할때 항상 코드를 읽음
- 코드를 짜는 사람은 저자, 코드를 읽는 사람은 독자.
    - 참신하고 재미있음

송영범

- 코드도 하나 문학이다.
- 코드도 글을 쓰는 것처럼 지속적인 검토와 첨삭이 필요하다.
- 좋은 코드는 좋은 결과를 낸다.

염수인

- 르블랑의 법칙: 미루면 이를 해결하는 시간은 결코 오지 않는다.

### 2장 **의미 있는 이름**

강동우

- 좋은 이름을 지으려면 시간이 오래걸리지만, 절약하는 시간이 더 크다.

송영범

- 차라리 길고 명확한 변수가 좋다.
- 변수 이름 정하기는 정말 어렵다.

염수인

- 변수나 메소드 이름을 짓는데에는 많은 경험과 공부가 필요하다.

### 3장 함수

강동우

- 인수를 최소화 하는 것이 이해가 잘 안되는 부분도 있다.

송영범

- 메소드와 함수를 잘 나누는 것은 추후 유지보수에 매우 유리하다.
- 메소드와 함수는 최대한 작게, 최대한 하나의 특정 작업만 하도록 개발하자.

염수인

- 인수의 개수를 줄이는 것도 매우 중요하다.

<br>

## 1. 노드 시작하기

### 노드의 정의

- 노드는 크롬 V8 자바스크립트 엔진, 빌드된 자바스크립트 런타임
- 웹 브라우저 없이 자바스크립트를 실행할 수 있도록 해줌
- 노드는 서버는 아니지만, 서버의 역할도 수행할 수 있음
- 자바스크립트 코드를 서버로 만들어주는 노드

### 런타임

- 특정 언어로 만든 프로그램을 실행할 수 있게 해주는 가상 머신
- 노드는 자바스크립트로 만든 프로그램들을 실행할 수 있음
- 이러한 런타임은 크롬, 파이어폭스 등 브라우저가 될 수 있음
- 이러한 브라우저 없이 런타임 환경을 제공하는 것이 노드

### 내부 구조

- C/C++로 개발
- C/C++은 생산성이 안좋기 때문에 노드는 자바스크립트를 사용
- libuv는 싱글스레드 비동기를 구현, 간단하게 좋은 성능을 얻기 쉬움

### 이벤트 기반

- 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식
- 이벤트를 등록하는 함수인 리벤트 리스너
- 이벤트가 발생했을 때 실행되는 함수는 콜백 함수

### 논 블로킹 I/O

- 노드는 동기면서 블로킹 / 비동기면서 논블로킹의 2가지만 존재
- 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 나중에 오래 걸리는 함수를 실행

### 프로세스 vs. 스레드

- 노드 프로세스는 멀티 스레드지만, 직접 다룰 수 있는 스레드는 하나이므로 싱글 스레드
- 노드는 멀티 스레드 대신 멀티 프로세스 사용
- 노드는 14버전 부터 멀티 스레드 사용 가능
- 다만 멀티 스레드는 개발이 매우 어려움

### 싱글 스레드

- 싱글 스레드라 주어진 일을 하나밖에 처리하지 못함
- 블로킹이 발생하는 경우 나머지 작업은 대기하여 비효율

### 멀티 스레드

- 싱글 스레드 모델은 에러를 처리하지 못하는 경우 멈춤
- 멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복

### 논 블로킹 모델

- 논 블로킹 모델을 통해 일부 코드(I/O)를 백그라운드(다른 프로세스)에서 실행 가능
- 기본적인 작업은 싱글 스레드이지만 타 작업을 다른 프로세스에서 실행

### 멀티 스레드의 활용

- 노드 14 버전부터 멀티 스레드 사용 가능
- 그러나 노드는 여전히 싱글 스레드 기반

### 서버로서의 노드

- 노드는 서버를 구성할 수 있게 하는 모듈을 제공
- 컴퓨터 자원을 적게 사용하는 것이 특징
- I/O 작업이 많은 서버로 적합
- 멀티 스레드 방식보다 쉬움
- 웹 서버가 내장
- 자바스크립스 사용
- JSON 형식과 호환이 쉬움
- 다만 높은 연산 및 대규모 서버에 적합하지 않음

### 서버 외의 노드

- 용도가 서버에만 한정되지 않음
- 웹, 모바일, 데스크탑 애플리케이션 개발 가능

### 노드 설치

- 노드 LTS 설치
- VS Code 설치

### 노드 핵심 3가지

- 실행 컨텍스트
- 이벤트 루프
- 프로토타입

<br>

## 자바스크립트 알아보기

### 호출 스택

- 코드가 실행되는 순서를 머리속에 그릴 줄 알아야함
- 함수를 호출할 때 쌓이는 스택
- Anonymus는 가상의 전역 컨텍스트(항상 존재)
- 함수 호출 순서대로 쌓이고, 역순으로 실행됨
- 함수 호출이 완료되면 스택에서 빠짐
- 동기적으로 실행할때 판단

### 이벤트 루프

- “호출 스택 - 백그라운드 - 테스크 큐”가 순환 하는 루프
- 백그라운드 작업이 끝나면 테스크 큐로 이동 후 호출 스택으로 올라감
- “호출 스택 - 백그라운드 - 테스크 큐”가 다 비어있어야지 프로그램이 종료된 것
- 백그라운드 작업이 될 수 있는 작업은 한정적
- 테스크 큐 또한 여러개 존재
- 호출 스택이 비어있어야지 테스크 큐에서 호출 스택으로 이동 가능
- 백그라운드는 어떤 것이 먼저 실행될지 모름, 먼저 끝나는 것이 테스크 큐로 이동
- then/catch/nextTick의 경우 테스크 큐에서 우선순위가 더 높기 때문에 먼저 실행
- 백그라운드는 운영체제 영역

### var, const, let

- var: 블록 스코프(중괄호)를 무시하는 변수, 함수 스코프는 존중
- const: 블록 스코프(중괄호)를 존중하는 상수
- let: 블록 스코프(중괄호)를 존중하는 변수

### 템플릿 문자열

- `${var}`을 통해 문자열 내에 변수 사용 가능
- func``을 통해 함수 호출 가능

### 객체 리터럴

- 훨씬 간결한 문법으로 객체 리터럴 표현 가능
- { sayNode: sayNode }와 같은 것을 { sayNode }로 축약 가능
- [ 변수 + 값 ] 등으로 동적 속성명을 객체 속성명으로 사용 가능

```jsx
const newObject = {
	sayJS() {
		console.log('js');
	}
	sayNode,
	[es + 6]: 'Fantastic'
}
```

### 화살표 함수

- 화살표를 사용하여 만드는 함수
- 더 간결하게 함수를 작성 가능
- Dart의 람다 함수와 유사
- 화살표 함수가 기존 function() {}을 대체하는 것은 아님(this가 달라짐)
- 화살표 함수는 자신의 this를 가지지 않음
- 기존 함수는 자신의 this를 가짐

### 비구조화 할당

- 구조화된 데이터를 조금 더 쉽게 할당할 수 있는 기능
- this가 있는 경우 비구조화 할당을 사용하면 안됨

### 클래스

- 프로토타입 문법을 깔끔하게 작성할 수 있음
- 객체지향프로그래밍 문법을 사용

### 프로미스

- 내용이 실행되었지만 결과를 아직 반환하지 않은 객체
- resolve는 성공, reject는 실패
- then를 통해 데이터를 가져올 수 있음
- 코드를 축약하고 분리할 수 있음
- 노드 생태계가 콜백에서 프로미스로 이동 중
- Async/await으로 코드를 더 축약 가능
- Async 함수는 항상 프로미스를 반환
- Dart의 비동기와 유사
- 비동기는 항상 실패를 염두하기

### 프론트엔드 자바스크립트

- AJAX 요청시 Axios 라이브러리를 사용하는게 편함
- FormData를 통해 form 데이터 전송 가능
- encode/decodeURIcomponent를 통해 주소창에 한글 사용 가능
- data attribute와 dataset을 통해 HTML 태그에 데이터 저장 가능